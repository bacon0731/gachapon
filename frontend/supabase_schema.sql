-- Enable UUID extension
CREATE EXTENSION IF NOT EXISTS "uuid-ossp";

-- DROP existing tables to ensure clean schema (resolves Type mismatch errors)
DROP TABLE IF EXISTS public.product_follows CASCADE;
DROP TABLE IF EXISTS public.draw_history CASCADE;
DROP TABLE IF EXISTS public.prizes CASCADE;
DROP TABLE IF EXISTS public.products CASCADE;
DROP TABLE IF EXISTS public.orders CASCADE;
DROP TABLE IF EXISTS public.delivery_orders CASCADE;
DROP TABLE IF EXISTS public.news CASCADE;
DROP TABLE IF EXISTS public.banners CASCADE;
DROP TABLE IF EXISTS public.categories CASCADE;
-- Note: profiles is not dropped to preserve user accounts, but handle_new_user ensures consistency.

-- 1. PROFILES (Extends Auth)
CREATE TABLE IF NOT EXISTS public.profiles (
  id UUID REFERENCES auth.users(id) ON DELETE CASCADE PRIMARY KEY,
  username TEXT,
  email TEXT,
  avatar_url TEXT,
  points INTEGER DEFAULT 0,
  recipient_name TEXT,
  recipient_phone TEXT,
  recipient_address TEXT,
  role TEXT DEFAULT 'user' CHECK (role IN ('user', 'admin')),
  status TEXT DEFAULT 'active' CHECK (status IN ('active', 'banned')),
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Ensure columns exist if table was already created (Migration for existing profiles)
DO $$
BEGIN
    ALTER TABLE public.profiles ADD COLUMN IF NOT EXISTS username TEXT;
    ALTER TABLE public.profiles ADD COLUMN IF NOT EXISTS email TEXT;
    ALTER TABLE public.profiles ADD COLUMN IF NOT EXISTS avatar_url TEXT;
    ALTER TABLE public.profiles ADD COLUMN IF NOT EXISTS points INTEGER DEFAULT 0;
    ALTER TABLE public.profiles ADD COLUMN IF NOT EXISTS recipient_name TEXT;
    ALTER TABLE public.profiles ADD COLUMN IF NOT EXISTS recipient_phone TEXT;
    ALTER TABLE public.profiles ADD COLUMN IF NOT EXISTS recipient_address TEXT;
    -- For role and status, we try to add them. If they exist but constraints are missing, this won't fix constraints, 
    -- but usually if columns are missing, this adds them with constraints.
    ALTER TABLE public.profiles ADD COLUMN IF NOT EXISTS role TEXT DEFAULT 'user' CHECK (role IN ('user', 'admin'));
    ALTER TABLE public.profiles ADD COLUMN IF NOT EXISTS status TEXT DEFAULT 'active' CHECK (status IN ('active', 'banned'));
EXCEPTION
    WHEN duplicate_object THEN NULL;
    WHEN OTHERS THEN NULL; -- Ignore errors if columns exist in a slightly different state
END $$;

-- 2. PRODUCTS (Ichiban Kuji Sets)
CREATE TABLE IF NOT EXISTS public.products (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  product_code TEXT UNIQUE,
  name TEXT NOT NULL,
  image_url TEXT,
  category TEXT DEFAULT '一番賞',
  price INTEGER NOT NULL DEFAULT 0,
  status TEXT DEFAULT 'pending' CHECK (status IN ('active', 'pending', 'ended')),
  is_hot BOOLEAN DEFAULT false,
  total_count INTEGER DEFAULT 0,
  remaining_count INTEGER DEFAULT 0,
  release_date DATE,
  created_at TIMESTAMPTZ DEFAULT NOW()
);

-- 3. PRIZES (Prizes within a Product)
CREATE TABLE IF NOT EXISTS public.prizes (
  id UUID DEFAULT uuid_generate_v4() PRIMARY KEY,
  product_id BIGINT REFERENCES public.products(id) ON DELETE CASCADE,
  grade TEXT NOT NULL, -- A, B, C, Last One
  name TEXT NOT NULL,
  image_url TEXT,
  quantity INTEGER NOT NULL DEFAULT 0,
  probability FLOAT,
  created_at TIMESTAMPTZ DEFAULT NOW()
);

-- 4. DRAW HISTORY (Inventory/Warehouse)
CREATE TABLE IF NOT EXISTS public.draw_history (
  id UUID DEFAULT uuid_generate_v4() PRIMARY KEY,
  user_id UUID REFERENCES public.profiles(id) ON DELETE CASCADE,
  product_id BIGINT REFERENCES public.products(id),
  prize_id UUID REFERENCES public.prizes(id),
  ticket_no TEXT,
  status TEXT DEFAULT 'in_warehouse' CHECK (status IN ('in_warehouse', 'pending_delivery', 'shipped', 'exchanged')),
  delivery_order_id UUID, -- Added reference to delivery_orders
  created_at TIMESTAMPTZ DEFAULT NOW(),
  cost INTEGER DEFAULT 0 -- Record the cost at draw time
);

-- 5. ORDERS (Topup/Payment)
CREATE TABLE IF NOT EXISTS public.orders (
  id UUID DEFAULT uuid_generate_v4() PRIMARY KEY,
  user_id UUID REFERENCES public.profiles(id) ON DELETE SET NULL,
  amount INTEGER NOT NULL,
  points INTEGER NOT NULL,
  payment_method TEXT,
  status TEXT DEFAULT 'pending' CHECK (status IN ('pending', 'paid', 'failed')),
  created_at TIMESTAMPTZ DEFAULT NOW()
);

-- 6. DELIVERY ORDERS (Shipment Requests)
CREATE TABLE IF NOT EXISTS public.delivery_orders (
  id UUID DEFAULT uuid_generate_v4() PRIMARY KEY,
  user_id UUID REFERENCES public.profiles(id) ON DELETE CASCADE,
  recipient_name TEXT,
  recipient_phone TEXT,
  recipient_address TEXT,
  shipping_method TEXT DEFAULT 'standard',
  tracking_number TEXT,
  status TEXT DEFAULT 'pending' CHECK (status IN ('pending', 'shipping', 'completed', 'cancelled')),
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- 7. PRODUCT FOLLOWS (User favorites)
CREATE TABLE IF NOT EXISTS public.product_follows (
  user_id UUID REFERENCES public.profiles(id) ON DELETE CASCADE,
  product_id BIGINT REFERENCES public.products(id) ON DELETE CASCADE,
  created_at TIMESTAMPTZ DEFAULT NOW(),
  PRIMARY KEY (user_id, product_id)
);

-- 8. NEWS (Announcements)
CREATE TABLE IF NOT EXISTS public.news (
  id UUID DEFAULT uuid_generate_v4() PRIMARY KEY,
  title TEXT NOT NULL,
  content TEXT,
  image_url TEXT,
  category TEXT,
  is_published BOOLEAN DEFAULT true,
  published_at TIMESTAMPTZ DEFAULT NOW(),
  created_at TIMESTAMPTZ DEFAULT NOW()
);

-- 9. BANNERS (Homepage Carousel)
CREATE TABLE IF NOT EXISTS public.banners (
  id UUID DEFAULT uuid_generate_v4() PRIMARY KEY,
  image_url TEXT NOT NULL,
  link_url TEXT,
  sort_order INTEGER DEFAULT 0,
  is_active BOOLEAN DEFAULT true,
  created_at TIMESTAMPTZ DEFAULT NOW()
);

-- 10. CATEGORIES (Product Categories)
CREATE TABLE IF NOT EXISTS public.categories (
  id TEXT PRIMARY KEY, -- slug, e.g. 'ichiban-kuji'
  name TEXT NOT NULL, -- display name, e.g. '一番賞'
  sort_order INTEGER DEFAULT 0,
  is_active BOOLEAN DEFAULT true,
  created_at TIMESTAMPTZ DEFAULT NOW()
);

-- RLS POLICIES

-- Enable RLS
ALTER TABLE public.profiles ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.products ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.prizes ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.draw_history ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.orders ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.delivery_orders ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.product_follows ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.news ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.banners ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.categories ENABLE ROW LEVEL SECURITY;

-- Profiles: Users can view/edit their own; Admins can view all
DROP POLICY IF EXISTS "Public profiles are viewable by everyone" ON public.profiles;
CREATE POLICY "Public profiles are viewable by everyone" ON public.profiles FOR SELECT USING (true);

DROP POLICY IF EXISTS "Users can insert their own profile" ON public.profiles;
CREATE POLICY "Users can insert their own profile" ON public.profiles FOR INSERT WITH CHECK (auth.uid() = id);

DROP POLICY IF EXISTS "Users can update own profile" ON public.profiles;
CREATE POLICY "Users can update own profile" ON public.profiles FOR UPDATE USING (auth.uid() = id);

-- Products & Prizes: Public read, Admin write
DROP POLICY IF EXISTS "Products are viewable by everyone" ON public.products;
CREATE POLICY "Products are viewable by everyone" ON public.products FOR SELECT USING (true);

DROP POLICY IF EXISTS "Admins can insert products" ON public.products;
CREATE POLICY "Admins can insert products" ON public.products FOR INSERT WITH CHECK (EXISTS (SELECT 1 FROM profiles WHERE id = auth.uid() AND role = 'admin'));

DROP POLICY IF EXISTS "Admins can update products" ON public.products;
CREATE POLICY "Admins can update products" ON public.products FOR UPDATE USING (EXISTS (SELECT 1 FROM profiles WHERE id = auth.uid() AND role = 'admin'));

DROP POLICY IF EXISTS "Prizes are viewable by everyone" ON public.prizes;
CREATE POLICY "Prizes are viewable by everyone" ON public.prizes FOR SELECT USING (true);

DROP POLICY IF EXISTS "Admins can insert prizes" ON public.prizes;
CREATE POLICY "Admins can insert prizes" ON public.prizes FOR INSERT WITH CHECK (EXISTS (SELECT 1 FROM profiles WHERE id = auth.uid() AND role = 'admin'));

DROP POLICY IF EXISTS "Admins can update prizes" ON public.prizes;
CREATE POLICY "Admins can update prizes" ON public.prizes FOR UPDATE USING (EXISTS (SELECT 1 FROM profiles WHERE id = auth.uid() AND role = 'admin'));

-- Draw History: Users view their own; Admins view all
DROP POLICY IF EXISTS "Users can view own draw history" ON public.draw_history;
CREATE POLICY "Users can view own draw history" ON public.draw_history FOR SELECT USING (auth.uid() = user_id);

DROP POLICY IF EXISTS "Users can insert own draw history" ON public.draw_history;
CREATE POLICY "Users can insert own draw history" ON public.draw_history FOR INSERT WITH CHECK (auth.uid() = user_id);

DROP POLICY IF EXISTS "Users can update own draw history" ON public.draw_history;
CREATE POLICY "Users can update own draw history" ON public.draw_history FOR UPDATE USING (auth.uid() = user_id);

-- Orders: Users view their own
DROP POLICY IF EXISTS "Users can view own orders" ON public.orders;
CREATE POLICY "Users can view own orders" ON public.orders FOR SELECT USING (auth.uid() = user_id);

DROP POLICY IF EXISTS "Users can insert own orders" ON public.orders;
CREATE POLICY "Users can insert own orders" ON public.orders FOR INSERT WITH CHECK (auth.uid() = user_id);

-- Delivery Orders: Users view their own
DROP POLICY IF EXISTS "Users can view own delivery orders" ON public.delivery_orders;
CREATE POLICY "Users can view own delivery orders" ON public.delivery_orders FOR SELECT USING (auth.uid() = user_id);

DROP POLICY IF EXISTS "Users can insert own delivery orders" ON public.delivery_orders;
CREATE POLICY "Users can insert own delivery orders" ON public.delivery_orders FOR INSERT WITH CHECK (auth.uid() = user_id);

DROP POLICY IF EXISTS "Users can update own delivery orders" ON public.delivery_orders;
CREATE POLICY "Users can update own delivery orders" ON public.delivery_orders FOR UPDATE USING (auth.uid() = user_id);

-- Product Follows: Users view/manage their own
DROP POLICY IF EXISTS "Users can view own follows" ON public.product_follows;
CREATE POLICY "Users can view own follows" ON public.product_follows FOR SELECT USING (auth.uid() = user_id);

DROP POLICY IF EXISTS "Users can insert own follows" ON public.product_follows;
CREATE POLICY "Users can insert own follows" ON public.product_follows FOR INSERT WITH CHECK (auth.uid() = user_id);

DROP POLICY IF EXISTS "Users can delete own follows" ON public.product_follows;
CREATE POLICY "Users can delete own follows" ON public.product_follows FOR DELETE USING (auth.uid() = user_id);

-- TRIGGERS

-- Function to handle new user creation
CREATE OR REPLACE FUNCTION public.handle_new_user()
RETURNS TRIGGER AS $$
BEGIN
  INSERT INTO public.profiles (id, email, username, avatar_url, role)
  VALUES (new.id, new.email, new.raw_user_meta_data->>'full_name', new.raw_user_meta_data->>'avatar_url', 'user');
  RETURN new;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Trigger for new user creation
DROP TRIGGER IF EXISTS on_auth_user_created ON auth.users;
CREATE TRIGGER on_auth_user_created
  AFTER INSERT ON auth.users
  FOR EACH ROW EXECUTE PROCEDURE public.handle_new_user();

-- RPC Function for Draw (Ichiban Kuji logic)
CREATE OR REPLACE FUNCTION public.play_ichiban(p_product_id BIGINT, p_ticket_numbers INTEGER[])
RETURNS JSONB
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
DECLARE
  v_user_id UUID;
  v_product_price INTEGER;
  v_prize RECORD;
  v_prizes_drawn JSONB := '[]'::jsonb;
  v_ticket_no INTEGER;
  v_ticket_str TEXT;
BEGIN
  v_user_id := auth.uid();
  IF v_user_id IS NULL THEN
    RAISE EXCEPTION 'Not authenticated';
  END IF;

  -- Check if tickets are already taken
  FOREACH v_ticket_no IN ARRAY p_ticket_numbers LOOP
    v_ticket_str := v_ticket_no::text;
    IF EXISTS (SELECT 1 FROM draw_history WHERE product_id = p_product_id AND ticket_no = v_ticket_str) THEN
      RAISE EXCEPTION 'Ticket % is already sold', v_ticket_no;
    END IF;
  END LOOP;

  -- Get product price
  SELECT price INTO v_product_price FROM products WHERE id = p_product_id;
  IF v_product_price IS NULL THEN
    RAISE EXCEPTION 'Product not found';
  END IF;

  -- Process each ticket
  FOREACH v_ticket_no IN ARRAY p_ticket_numbers LOOP
    -- Draw prize
    SELECT * INTO v_prize FROM prizes 
    WHERE product_id = p_product_id AND quantity > 0
    ORDER BY random() * probability DESC
    LIMIT 1;

    IF v_prize IS NULL THEN
      RAISE EXCEPTION 'No prizes left';
    END IF;

    -- Update prize quantity
    UPDATE prizes SET quantity = quantity - 1 WHERE id = v_prize.id;
    
    -- Update product remaining count
    UPDATE products SET remaining_count = remaining_count - 1 WHERE id = p_product_id;

    -- Record draw history with SPECIFIC TICKET NUMBER
    INSERT INTO draw_history (user_id, product_id, prize_id, ticket_no, cost)
    VALUES (v_user_id, p_product_id, v_prize.id, v_ticket_no::text, v_product_price);

    v_prizes_drawn := v_prizes_drawn || jsonb_build_object(
      'grade', v_prize.grade,
      'name', v_prize.name,
      'image_url', v_prize.image_url,
      'ticket_no', v_ticket_no
    );
  END LOOP;

  RETURN v_prizes_drawn;
END;
$$;

-- News Policies
DROP POLICY IF EXISTS "News are viewable by everyone" ON public.news;
CREATE POLICY "News are viewable by everyone" ON public.news FOR SELECT USING (true);

DROP POLICY IF EXISTS "Admins can insert news" ON public.news;
CREATE POLICY "Admins can insert news" ON public.news FOR INSERT WITH CHECK (EXISTS (SELECT 1 FROM profiles WHERE id = auth.uid() AND role = 'admin'));

DROP POLICY IF EXISTS "Admins can update news" ON public.news;
CREATE POLICY "Admins can update news" ON public.news FOR UPDATE USING (EXISTS (SELECT 1 FROM profiles WHERE id = auth.uid() AND role = 'admin'));

DROP POLICY IF EXISTS "Admins can delete news" ON public.news;
CREATE POLICY "Admins can delete news" ON public.news FOR DELETE USING (EXISTS (SELECT 1 FROM profiles WHERE id = auth.uid() AND role = 'admin'));

-- Banners Policies
DROP POLICY IF EXISTS "Banners are viewable by everyone" ON public.banners;
CREATE POLICY "Banners are viewable by everyone" ON public.banners FOR SELECT USING (true);

DROP POLICY IF EXISTS "Admins can insert banners" ON public.banners;
CREATE POLICY "Admins can insert banners" ON public.banners FOR INSERT WITH CHECK (EXISTS (SELECT 1 FROM profiles WHERE id = auth.uid() AND role = 'admin'));

DROP POLICY IF EXISTS "Admins can update banners" ON public.banners;
CREATE POLICY "Admins can update banners" ON public.banners FOR UPDATE USING (EXISTS (SELECT 1 FROM profiles WHERE id = auth.uid() AND role = 'admin'));

DROP POLICY IF EXISTS "Admins can delete banners" ON public.banners;
CREATE POLICY "Admins can delete banners" ON public.banners FOR DELETE USING (EXISTS (SELECT 1 FROM profiles WHERE id = auth.uid() AND role = 'admin'));

-- Categories Policies
DROP POLICY IF EXISTS "Categories are viewable by everyone" ON public.categories;
CREATE POLICY "Categories are viewable by everyone" ON public.categories FOR SELECT USING (true);

DROP POLICY IF EXISTS "Admins can insert categories" ON public.categories;
CREATE POLICY "Admins can insert categories" ON public.categories FOR INSERT WITH CHECK (EXISTS (SELECT 1 FROM profiles WHERE id = auth.uid() AND role = 'admin'));

DROP POLICY IF EXISTS "Admins can update categories" ON public.categories;
CREATE POLICY "Admins can update categories" ON public.categories FOR UPDATE USING (EXISTS (SELECT 1 FROM profiles WHERE id = auth.uid() AND role = 'admin'));

DROP POLICY IF EXISTS "Admins can delete categories" ON public.categories;
CREATE POLICY "Admins can delete categories" ON public.categories FOR DELETE USING (EXISTS (SELECT 1 FROM profiles WHERE id = auth.uid() AND role = 'admin'));
