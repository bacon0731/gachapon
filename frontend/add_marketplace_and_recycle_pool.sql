-- Marketplace & Recycle Pool System
-- Combined script for P2P Auction and Dismantle Tracking

-- ==========================================
-- Part 1: Marketplace System
-- ==========================================

-- 1. Add is_tradable column to draw_records
DO $$
BEGIN
    IF NOT EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'draw_records' AND column_name = 'is_tradable') THEN
        ALTER TABLE draw_records ADD COLUMN is_tradable BOOLEAN DEFAULT true;
    END IF;
END $$;

-- 2. Update status constraint to include 'listing'
DO $$
DECLARE
    r RECORD;
BEGIN
    SELECT conname INTO r
    FROM pg_constraint 
    WHERE conrelid = 'draw_records'::regclass 
    AND contype = 'c' 
    AND pg_get_constraintdef(oid) LIKE '%status%';
    IF FOUND THEN
        EXECUTE 'ALTER TABLE draw_records DROP CONSTRAINT ' || r.conname;
    END IF;
    ALTER TABLE draw_records ADD CONSTRAINT draw_records_status_check 
    CHECK (status IN ('in_warehouse', 'pending_delivery', 'shipped', 'exchanged', 'dismantled', 'listing'));
END $$;

-- 3. Create Marketplace Listings Table
CREATE TABLE IF NOT EXISTS marketplace_listings (
    id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    seller_id UUID NOT NULL REFERENCES users(id),
    draw_record_id BIGINT NOT NULL REFERENCES draw_records(id),
    price INTEGER NOT NULL CHECK (price > 0),
    status VARCHAR(20) NOT NULL CHECK (status IN ('active', 'sold', 'cancelled')) DEFAULT 'active',
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- 4. Create Marketplace Transactions Table (Log)
CREATE TABLE IF NOT EXISTS marketplace_transactions (
    id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    listing_id BIGINT REFERENCES marketplace_listings(id),
    buyer_id UUID REFERENCES users(id),
    seller_id UUID REFERENCES users(id),
    draw_record_id BIGINT REFERENCES draw_records(id),
    price INTEGER NOT NULL,
    fee INTEGER NOT NULL,
    seller_receive INTEGER NOT NULL,
    created_at TIMESTAMPTZ DEFAULT NOW()
);

-- 5. Function: Create Listing
CREATE OR REPLACE FUNCTION create_listing(
    p_record_id BIGINT,
    p_price INTEGER,
    p_user_id UUID
) RETURNS JSONB AS $$
DECLARE
    v_record RECORD;
BEGIN
    -- Check ownership and status
    SELECT * INTO v_record FROM draw_records 
    WHERE id = p_record_id AND user_id = p_user_id;

    IF v_record IS NULL THEN
        RETURN jsonb_build_object('success', false, 'message', 'Item not found or access denied');
    END IF;

    IF v_record.status != 'in_warehouse' THEN
        RETURN jsonb_build_object('success', false, 'message', 'Item is not in warehouse');
    END IF;

    IF v_record.is_tradable = false THEN
        RETURN jsonb_build_object('success', false, 'message', 'Item is bound and cannot be traded');
    END IF;

    -- Update record status
    UPDATE draw_records SET status = 'listing' WHERE id = p_record_id;

    -- Create listing
    INSERT INTO marketplace_listings (seller_id, draw_record_id, price)
    VALUES (p_user_id, p_record_id, p_price);

    RETURN jsonb_build_object('success', true, 'message', 'Listing created');
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- 6. Function: Cancel Listing
CREATE OR REPLACE FUNCTION cancel_listing(
    p_listing_id BIGINT,
    p_user_id UUID
) RETURNS JSONB AS $$
DECLARE
    v_listing RECORD;
BEGIN
    SELECT * INTO v_listing FROM marketplace_listings 
    WHERE id = p_listing_id AND seller_id = p_user_id AND status = 'active';

    IF v_listing IS NULL THEN
        RETURN jsonb_build_object('success', false, 'message', 'Listing not found or not active');
    END IF;

    -- Update listing status
    UPDATE marketplace_listings SET status = 'cancelled', updated_at = NOW() WHERE id = p_listing_id;

    -- Return item to warehouse
    UPDATE draw_records SET status = 'in_warehouse' WHERE id = v_listing.draw_record_id;

    RETURN jsonb_build_object('success', true, 'message', 'Listing cancelled');
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- 7. Function: Purchase Listing
CREATE OR REPLACE FUNCTION purchase_listing(
    p_listing_id BIGINT,
    p_buyer_id UUID
) RETURNS JSONB AS $$
DECLARE
    v_listing RECORD;
    v_buyer_tokens INTEGER;
    v_fee INTEGER;
    v_seller_receive INTEGER;
BEGIN
    -- Get listing info
    SELECT * INTO v_listing FROM marketplace_listings 
    WHERE id = p_listing_id AND status = 'active';

    IF v_listing IS NULL THEN
        RETURN jsonb_build_object('success', false, 'message', 'Listing not found or no longer active');
    END IF;

    -- IF v_listing.seller_id = p_buyer_id THEN
    --    RETURN jsonb_build_object('success', false, 'message', 'Cannot buy your own listing');
    -- END IF;

    -- Check buyer balance
    SELECT tokens INTO v_buyer_tokens FROM users WHERE id = p_buyer_id;
    
    IF v_buyer_tokens < v_listing.price THEN
        RETURN jsonb_build_object('success', false, 'message', 'Insufficient tokens');
    END IF;

    -- Calculate fee (5%)
    v_fee := FLOOR(v_listing.price * 0.05);
    v_seller_receive := v_listing.price - v_fee;

    -- Process Transaction
    -- 1. Deduct from buyer
    UPDATE users SET tokens = tokens - v_listing.price WHERE id = p_buyer_id;

    -- 2. Add to seller
    UPDATE users SET tokens = tokens + v_seller_receive WHERE id = v_listing.seller_id;

    -- 3. Update Listing
    UPDATE marketplace_listings SET status = 'sold', updated_at = NOW() WHERE id = p_listing_id;

    -- 4. Transfer Item Ownership and Mark as Bound (Not Tradable)
    UPDATE draw_records 
    SET user_id = p_buyer_id, 
        status = 'in_warehouse',
        is_tradable = false  -- BINDING LOGIC
    WHERE id = v_listing.draw_record_id;

    -- 5. Log Transaction
    INSERT INTO marketplace_transactions (listing_id, buyer_id, seller_id, draw_record_id, price, fee, seller_receive)
    VALUES (p_listing_id, p_buyer_id, v_listing.seller_id, v_listing.draw_record_id, v_listing.price, v_fee, v_seller_receive);

    RETURN jsonb_build_object('success', true, 'message', 'Purchase successful');
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- 8. Enable RLS
ALTER TABLE marketplace_listings ENABLE ROW LEVEL SECURITY;

-- Policy: Everyone can view active listings
DROP POLICY IF EXISTS "View active listings" ON marketplace_listings;
CREATE POLICY "View active listings" ON marketplace_listings
FOR SELECT USING (status = 'active' OR seller_id = auth.uid());

-- Policy: Sellers can update their own listings (for cancellation logic mainly handled by RPC but good for safety)
DROP POLICY IF EXISTS "Sellers manage listings" ON marketplace_listings;
CREATE POLICY "Sellers manage listings" ON marketplace_listings
FOR ALL USING (seller_id = auth.uid());


-- ==========================================
-- Part 2: Recycle Pool System (Admin Table)
-- ==========================================

-- 1. Create Recycle Pool Table
CREATE TABLE IF NOT EXISTS admin_recycle_pool (
    id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    product_prize_id BIGINT NOT NULL REFERENCES product_prizes(id),
    original_draw_record_id BIGINT REFERENCES draw_records(id),
    dismantled_at TIMESTAMPTZ DEFAULT NOW(),
    status VARCHAR(20) NOT NULL CHECK (status IN ('available', 'reused')) DEFAULT 'available',
    reused_at TIMESTAMPTZ
);

-- 2. Enable RLS (Admin Only - simplified for now, usually needs admin role check)
ALTER TABLE admin_recycle_pool ENABLE ROW LEVEL SECURITY;

-- 3. Update dismantle_prizes function to feed the pool
CREATE OR REPLACE FUNCTION dismantle_prizes(
  p_record_ids BIGINT[],
  p_user_id UUID
) RETURNS TABLE (
  success_count INTEGER,
  total_refund INTEGER
) AS $$
DECLARE
  v_record RECORD;
  v_refund INTEGER := 0;
  v_count INTEGER := 0;
  v_prize_value INTEGER;
BEGIN
  FOR v_record IN 
    SELECT dr.id, dr.product_prize_id, pp.recycle_value
    FROM draw_records dr
    JOIN product_prizes pp ON dr.product_prize_id = pp.id
    WHERE dr.id = ANY(p_record_ids)
      AND dr.user_id = p_user_id
      AND dr.status = 'in_warehouse'
  LOOP
    v_prize_value := COALESCE(v_record.recycle_value, 0);
    IF v_prize_value > 0 THEN
      -- 1. Update Draw Record
      UPDATE draw_records SET status = 'dismantled' WHERE id = v_record.id;
      
      -- 2. Insert into Recycle Pool
      INSERT INTO admin_recycle_pool (product_prize_id, original_draw_record_id)
      VALUES (v_record.product_prize_id, v_record.id);
      
      -- 3. Calculate Refund
      v_refund := v_refund + v_prize_value;
      v_count := v_count + 1;
    END IF;
  END LOOP;
  
  -- 4. Refund User
  IF v_refund > 0 THEN
    UPDATE users SET tokens = tokens + v_refund WHERE id = p_user_id;
  END IF;
  
  RETURN QUERY SELECT v_count, v_refund;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;
